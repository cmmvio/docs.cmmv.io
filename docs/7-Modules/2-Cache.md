# Cache

The ``@cmmv/cache`` module integrates with ``cache-manager`` to provide in-memory cache management. By default, it includes support for Redis using the ``@tirke/node-cache-manager-ioredis`` package, but it also supports other cache stores that are compatible with ``cache-manager``.

To install the ``@cmmv/cache`` module, use npm:

```bash
$ pnpm add @cmmv/cache cache-manager
$ pnpm add -D @types/cache-manager
```

If you're planning to use Redis or other stores, you'll need to install the appropriate package based on the cache store you intend to use.

**Supported Cache Stores and Drivers**

``cache-manager`` supports various cache stores, and you can configure your store based on your requirements. Here are the supported stores and their respective drivers:

**Redis:** [Github](https://github.com/Tirke/node-cache-manager-stores/tree/main)

```bash
$ pnpm add @tirke/node-cache-manager-ioredis
```

**Memcached:** [Github](https://github.com/theogravity/node-cache-manager-memcached-store)

```bash
$ pnpm add cache-manager-memcached-store
```

**MongoDB:** [Github](https://github.com/v4l3r10/node-cache-manager-mongodb)

```bash
$ pnpm add cache-manager-mongodb
```

**Filesystem Binary:** [Github](https://github.com/sheershoff/node-cache-manager-fs-binary)

```bash
$ pnpm add cache-manager-fs-binary
```

## Configuration

```javascript
module.exports = {
   // Other configurations

   cache: {
        store: "@tirke/node-cache-manager-ioredis",
        getter: "ioRedisStore",
        host: "localhost",
        port: 6379,
        ttl: 600 // Cache TTL (Time-to-Live) in seconds
    },
}
```

<br/>

* **store:** Defines the cache store type (``cache-manager-redis`` in this case).
* **host:** Specifies the Redis host.
* **port:** Specifies the Redis port.
* **ttl:** Defines the default time-to-live for cache entries (in seconds).

To find out all the possible configurations, visit [NPM](https://www.npmjs.com/package/cache-manager)

## Cache Decorator

In this example, we demonstrate how to manually implement caching using the ``@cmmv/cache`` module in a controller generated by ``@cmmv/http``. Caching can be added at various levels, including for specific endpoints or manually after certain operations, like adding or updating records.

* **Controller:** ``TaskController`` is responsible for handling requests related to tasks.
* **Cache Decorator:** The ``@Cache`` decorator is used to cache responses automatically for GET endpoints. In this case, ``task:getAll`` and ``task:{id}`` are cached for 300 seconds with compression.
* **CacheService:** For ``POST``, ``PUT``, and ``DELETE`` operations, the cache is updated or removed manually using the ``CacheService`` API.

```typescript
// Generated automatically by CMMV
    
import { Telemetry } from "@cmmv/core";  
import { Cache, CacheService } from "@cmmv/cache"; 

import { 
    Controller, Get, Post, Put, Delete, 
    Queries, Param, Body, Request 
} from '@cmmv/http';

import { TaskService } from '../services/task.service';
import { Task } from '../models/task.model';

@Controller('task')
export class TaskController {
    constructor(private readonly taskservice: TaskService) {}

    // GET All Tasks with Cache
    @Get()
    @Cache("task:getAll", { ttl: 300, compress: true })
    async getAll(@Queries() queries: any, @Request() req): Promise<Task[]> {
        Telemetry.start('TaskController::GetAll', req.requestId);
        let result = await this.taskservice.getAll(queries, req);
        Telemetry.end('TaskController::GetAll', req.requestId);
        return result;
    }

    // GET Task by ID with Cache
    @Get(':id')
    @Cache("task:{id}", { ttl: 300, compress: true })
    async getById(@Param('id') id: string, @Request() req): Promise<Task> {
        Telemetry.start('TaskController::GetById', req.requestId);
        let result = await this.taskservice.getById(id, req);
        Telemetry.end('TaskController::GetById', req.requestId);
        return result;
    }

    // POST (Add Task) and Update Cache
    @Post()
    async add(@Body() item: Task, @Request() req): Promise<Task> {
        Telemetry.start('TaskController::Add', req.requestId);
        let result = await this.taskservice.add(item, req);
        
        // Cache the result of the newly created task
        CacheService.set(`task:${result.id}`, JSON.stringify(result), 300);
        
        Telemetry.end('TaskController::Add', req.requestId);
        return result;
    }

    // PUT (Update Task) and Update Cache
    @Put(':id')
    async update(
        @Param('id') id: string, @Body() item: Task, @Request() req
    ): Promise<Task> {
        Telemetry.start('TaskController::Update', req.requestId);
        let result = await this.taskservice.update(id, item, req);
        
        // Update the cache with the updated task
        CacheService.set(`task:${result.id}`, JSON.stringify(result), 300);
        
        Telemetry.end('TaskController::Update', req.requestId);
        return result;
    }

    // DELETE (Remove Task) and Clear Cache
    @Delete(':id')
    async delete(
        @Param('id') id: string, @Request() req
    ): Promise<{ success: boolean, affected: number }> {
        Telemetry.start('TaskController::Delete', req.requestId);
        let result = await this.taskservice.delete(id, req);
        
        // Remove the deleted task from the cache
        CacheService.del(`task:${id}`);
        
        Telemetry.end('TaskController::Delete', req.requestId);
        return result;
    }
}
```

**Caching on GET Requests:**

* **Automatic Caching:** The @Cache decorator is applied to the getAll and getById methods. Cached results are automatically stored and retrieved based on the key pattern, reducing database load and improving performance.
* **Cache Key:** Cache keys are defined as task:getAll for retrieving all tasks, and task:{id} for retrieving a task by ID.
TTL (Time-to-Live): The cached results are valid for 300 seconds.

**Manual Caching for ``POST``, ``PUT``, and ``DELETE``:**

* For ``POST`` (creating a new task) and ``PUT`` (updating a task), the ``CacheService.set`` method is used to manually update the cache with the new or updated task.
* For ``DELETE`` (removing a task), the ``CacheService.del`` method is used to remove the corresponding cache entry after the task is deleted.
* **Telemetry:** Tracks and logs the execution of each method, useful for performance monitoring.

This setup optimizes response time by caching frequently accessed data while ensuring that cache entries are updated or cleared when data is modified.

## Contract Settings

The ``@cmmv/cache`` module provides the ``Cache`` decorator, which can be applied to any controller, gateway, or specific methods. This decorator is useful for automatically caching responses for specific routes.

In the following example, cache properties are added to a contract using the ``@Contract`` decorator. This enables caching for the associated controller and gateway routes automatically generated by the transpiler.

```typescript
import { AbstractContract, Contract, ContractField } from '@cmmv/core';

@Contract({
    controllerName: 'Task',
    protoPath: 'src/protos/task.proto',
    protoPackage: 'task',
    cache: { 
        key: "task:",   // Cache key prefix
        ttl: 300,       // Time-to-live (in seconds)
        compress: true  // Enable compression for stored data
    }
})
export class TasksContract extends AbstractContract {
    @ContractField({
        protoType: 'string',
        unique: true,
        validations: [
            {
                type: 'IsString',
                message: 'Invalid label',
            },
            {
                type: 'IsNotEmpty',
                message: 'Invalid label',
            },
        ],
    })
    label: string;

    @ContractField({
        protoType: 'bool',
        defaultValue: false,
        validations: [
            {
                type: 'IsBoolean',
                message: 'Invalid checked type',
            },
        ],
    })
    checked: boolean;

    @ContractField({
        protoType: 'bool',
        defaultValue: false,
        validations: [
            {
                type: 'IsBoolean',
                message: 'Invalid removed type',
            },
        ],
    })
    removed: boolean;
}
```

## Cache Properties

* **key:** A prefix for the cache key. In the example above, it is ``"task:"``. For a ``getAll`` request, the cached result will be stored as ``task:getAll``.
* **ttl:** The time-to-live for cached data. After 300 seconds, the cache entry will expire.
* **compress:** Enables compression of the data before storing it in the cache to reduce memory usage.

If you need more advanced caching strategies or custom store integrations, you can customize the cache settings in the ``.cmmv.config.js`` file or extend the existing cache functionalities within your project. For example, you could add custom cache strategies like memory caching, database caching, or even multi-level caching.

## Controllers 

When the ``@cmmv/cache`` module is included in the project, the automatically generated controllers from ``@cmmv/http`` are modified to include caching functionalities. The caching configuration is defined directly in the contract using the cache property. Here's how the controller is altered:

```typescript
import { AbstractContract, Contract, ContractField } from '@cmmv/core';

@Contract({
    controllerName: 'Task',
    protoPath: 'src/protos/task.proto',
    protoPackage: 'task',
    cache: { 
        key: "task:", 
        ttl : 300, 
        compress: true 
    }
})
export class TasksContract extends AbstractContract {
    @ContractField({
        protoType: 'string',
        unique: true,
        validations: [
            {
                type: 'IsString',
                message: 'Invalid label',
            },
            {
                type: 'IsNotEmpty',
                message: 'Label cannot be empty',
            },
        ],
    })
    label: string;

    @ContractField({
        protoType: 'bool',
        defaultValue: false,
        validations: [
            {
                type: 'IsBoolean',
                message: 'Checked value must be a boolean',
            },
        ],
    })
    checked: boolean;

    @ContractField({
        protoType: 'bool',
        defaultValue: false,
        validations: [
            {
                type: 'IsBoolean',
                message: 'Removed value must be a boolean',
            },
        ],
    })
    removed: boolean;
}
```

Based on the above contract with cache configuration, the generated controller will include caching logic using the ``@Cache`` decorator from ``@cmmv/cache``. Hereâ€™s an example of how the controller is generated:

```typescript
// Generated automatically by CMMV

import { Telemetry } from "@cmmv/core";  
import { Cache, CacheService } from "@cmmv/cache"; 

import { 
    Controller, Get, Post, Put, Delete, 
    Queries, Param, Body, Request 
} from '@cmmv/http';

import { TaskService } from '../services/task.service';
import { Task } from '../models/task.model';

@Controller('task')
export class TaskController {
    constructor(private readonly taskservice: TaskService) {}

    @Get()
    @Cache("task:getAll", { ttl: 300, compress: true })
    async getAll(@Queries() queries: any, @Request() req): Promise<Task[]> {
        Telemetry.start('TaskController::GetAll', req.requestId);
        let result = await this.taskservice.getAll(queries, req);
        Telemetry.end('TaskController::GetAll', req.requestId);
        return result;
    }

    @Get(':id')
    @Cache("task:{id}", { ttl: 300, compress: true })
    async getById(@Param('id') id: string, @Request() req): Promise<Task> {
        Telemetry.start('TaskController::GetById', req.requestId);
        let result = await this.taskservice.getById(id, req);
        Telemetry.end('TaskController::GetById', req.requestId);
        return result;
    }

    @Post()
    async add(@Body() item: Task, @Request() req): Promise<Task> {
        Telemetry.start('TaskController::Add', req.requestId);
        let result = await this.taskservice.add(item, req);
        CacheService.set(`task:${result.id}`, JSON.stringify(result), 300);
        Telemetry.end('TaskController::Add', req.requestId);
        return result;
    }

    @Put(':id')
    async update(
        @Param('id') id: string, @Body() item: Task, @Request() req
    ): Promise<Task> {
        Telemetry.start('TaskController::Update', req.requestId);
        let result = await this.taskservice.update(id, item, req);
        CacheService.set(`task:${result.id}`, JSON.stringify(result), 300);
        Telemetry.end('TaskController::Update', req.requestId);
        return result;
    }

    @Delete(':id')
    async delete(
        @Param('id') id: string, @Request() req
    ): Promise<{ success: boolean, affected: number }> {
        Telemetry.start('TaskController::Delete', req.requestId);
        let result = await this.taskservice.delete(id, req);
        CacheService.del(`task:${id}`);
        Telemetry.end('TaskController::Delete', req.requestId);
        return result;
    }
}
```

* **Cache Decorator:** The ``@Cache`` decorator is added to methods like ``getAll`` and ``getById`` based on the cache configuration provided in the contract. This decorator automatically caches the results for the specified time (``ttl``) and applies compression (``compress``) if configured.

* **``@Cache("task:getAll", { ttl: 300, compress: true })``:** This line configures caching for the ``getAll method``, where the cache key is ``task:getAll``, with a TTL of 300 seconds, and compresses the cached data.

* **Manual Cache Management:** In ``add``, ``update``, and ``delete`` methods, manual cache management is applied. The ``CacheService.set`` and ``CacheService.del`` methods are used to update or delete cached data.

* **``CacheService.set("task:{id}", JSON.stringify(result), 300)``:** Manually sets the cache for a specific task after adding or updating it.
* **``CacheService.del("task:{id}")``:** Deletes the cache for a specific task after it is deleted.
* **Dynamic Cache Keys:** The cache keys are dynamic, as shown in the ``getById``, ``add``, ``update``, and ``delete`` methods, where the task ID is part of the cache key.

The ``@cmmv/cache`` module enhances the generated controllers by adding automatic and manual caching capabilities based on the contract's cache configuration. The ``@Cache`` decorator is applied to methods where needed, and the ``CacheService`` is used to manage cache entries for specific tasks or resources. This ensures better performance by reducing redundant database queries or service calls.

## Gateways

When the ``@cmmv/cache`` module is present in the project, gateways generated by the ``@cmmv/ws`` module are modified to include caching functionality. The cache configuration can be defined in the contract and impacts how RPC messages are handled.

* **Cache Decorator:** The ``@Cache`` decorator is applied to message handlers in the gateway, enabling automatic caching of responses. The cache key, TTL (time-to-live), and compression options are based on the configuration from the contract.

* **Manual Cache Management:** Cache entries are manually updated or deleted when new data is added or modified, ensuring that the cache remains consistent with the latest data.

```typescript
// Generated automatically by CMMV

import { Rpc, Message, Data, Socket, RpcUtils } from "@cmmv/ws";
import { plainToClass } from 'class-transformer';
import { TaskEntity } from '../entities/task.entity';
import { Cache, CacheService } from "@cmmv/cache"; // Cache module

import { 
    AddTaskRequest, 
    UpdateTaskRequest,   
    DeleteTaskRequest 
} from "../protos/task";

import { TaskService } from '../services/task.service';

@Rpc("task")
export class TaskGateway {
    constructor(private readonly taskservice: TaskService) {}

    @Message("GetAllTaskRequest")
    @Cache("task:getAll", { ttl: 300, compress: true }) // Cache decorator
    async getAll(@Socket() socket) {
        const items = await this.taskservice.getAll();

        const response = await RpcUtils.pack(
            "task", "GetAllTaskResponse", items
        );

        socket.send(response);
    }

    @Message("AddTaskRequest")
    async add(@Data() data: AddTaskRequest, @Socket() socket) {
        const entity = plainToClass(TaskEntity, data.item);
        const result = await this.taskservice.add(entity);

        const response = await RpcUtils.pack(
            "task", "AddTaskResponse", 
            { item: result, id: result.id }
        );

        CacheService.set(// Manual cache update
            `task:${result.id}`, 
            JSON.stringify(result), 
            300
        ); 

        socket.send(response);
    }

    @Message("UpdateTaskRequest")
    async update(@Data() data: UpdateTaskRequest, @Socket() socket) {
        const entity = plainToClass(TaskEntity, data.item);
        const result = await this.taskservice.update(data.id, entity);

        const response = await RpcUtils.pack(
            "task", "UpdateTaskResponse", 
            {  item: result, id: result.id }
        );

        CacheService.set(// Manual cache update
            `task:${result.id}`, 
            JSON.stringify(result), 
            300
        ); 

        socket.send(response);
    }

    @Message("DeleteTaskRequest")
    async delete(@Data() data: DeleteTaskRequest, @Socket() socket) {
        const result = (await this.taskservice.delete(data.id)).success;

        const response = await RpcUtils.pack(
            "task", 
            "DeleteTaskResponse", 
            { success: result, id: data.id }
        );

        CacheService.del(`task:${data.id}`); // Cache deletion
        
        socket.send(response);
    }
}
```

<br/>

* **Automatic Caching:** The ``@Cache`` decorator is applied to message handlers to cache responses based on the contract configuration.
* **Manual Cache Management:** Cache entries are manually updated or deleted when data is added, updated, or deleted, ensuring consistency.
* **Performance Improvement:** Cached responses reduce the need for repeated service calls, improving the performance of RPC interactions.